# Skills vs Subagents 設計判断ガイド

## 結論サマリ

- **skills** = 文脈を共有したまま「思考様式」を注入するもの
- **subagents** = 文脈を切り離して「仕事」を外注するもの

## 判断軸

| 観点 | skills | subagents |
|------|--------|-----------|
| コンテキスト | 共有する | 分離する |
| Claude Codeの思考 | 拡張する | 委譲する |
| 途中経過 | 親と常に共有 | 見えなくてよい |
| 失敗・試行錯誤 | 親が抱える | 子が抱える |
| 親が欲しいもの | プロセス込み | 結果・要約 |

---

## 1. コンテキスト消費の違い

### skills のコンテキスト消費

- 同一コンテキスト内でトークンを積み上げる
- すべて親に残る
- RED→GREEN→REFACTOR など「履歴が価値」
- **ストーリーが重要**

### subagents のコンテキスト消費

- 別スレッドで消費
- 親には「要約」だけ返る
- 内部の試行錯誤は捨てられる
- **ストーリーは不要、成果物だけ重要**

---

## 2. skills を選ぶべきケース

### 思考の型を強制したい

- TDD
- セキュアコーディング
- アーキテクチャレビュー視点
- 文章校正の観点（論理・トーン・構造）

→ 「どう考えるか」を差し込む

### 文脈を強く参照する

- 既存コードの意図
- 直前の議論
- 途中で変えた方針

→ skills = CLAUDE.md を条件付きで差し込む装置

### 親の意思決定に影響する

- 「この設計はなぜこうしたか」
- 「ここは妥協した理由」

→ 結果だけだと危険

### skills のアンチパターン

以下は subagent に委譲すべき：

- 大量ログを読む
- エラーを総当たり
- 外部仕様を探索

---

## 3. subagents を選ぶべきケース

### 試行錯誤が本質のタスク

- エラー原因調査
- ビルド失敗の切り分け
- flaky test の再現
- 依存関係地獄

→ 人間でも頭が混乱するやつ

### 親が詳細を知らなくていい

- 「原因と対処だけ」
- 「結論＋再発防止」

→ subagent = 有能な部下に丸投げ

### 巨大入力が必要

- ログ全文
- 大規模コードベースの探索
- ドキュメント群の横断検索

→ 親コンテキストを守る

### subagents のアンチパターン

以下は skills で対応すべき：

- 設計判断
- 方針転換
- 連続した改善サイクル

---

## 4. 両者を混ぜた構成（上級）

例：TDD + バグ調査

```
[skills] TDD思考、設計方針
    ↓
[subagent] エラー再現、原因特定
    ↓
[skills] 原因を踏まえたテスト追加、リファクタ
```

→ 思考 → 外注 → 思考（人間のチーム構成と同じ）

---

## 5. slash commands との整理

| 仕組み | 役割 |
|--------|------|
| slash command | 命令そのもの |
| skill | 命令を「いつ自動で使うか」の判断 |
| subagent | 命令を「誰にやらせるか」 |

### 黄金パターン

- **slash command** = 手動トリガ
- **skill** = 自動トリガ
- **subagent** = 実行主体

---

## 6. 判断フローチャート

```
このタスクは？
 ├ 思考の流れが重要 → skills
 ├ 結果だけ欲しい → subagent
 ├ 巨大 or 試行錯誤 → subagent
 ├ 文脈を引き継ぐ → skills
 └ 手動でしか使わない → slash command
```

---

## 7. まとめ

- **skills** = 「考え方のプラグイン」
- **subagents** = 「記憶を分けた別人格」

この理解で以下の判断が容易になる：

- 「CLAUDE.mdに書くか？」
- 「skillにするか？」
- 「subagentに逃がすか？」
